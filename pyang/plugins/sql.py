"""SQL plugin

Creates SQL schema from YANG files.
"""

from pyang import plugin, statements, error
from pyang.util import unique_prefixes

"""Dictionary of SQL namespaces. Key will be the prefix of yang model"""
schemata={}

type_class = dict([
    ("int8", "INTEGER"),
    ("uint8", "INTEGER"),
    ("int16", "INTEGER"),
    ("uint16", "INTEGER"),
    ("int32", "INTEGER"),
    ("uint32","INTEGER"),
    ("int64", "INTEGER"),
    ("uint64","INTEGER"),
    ("decimal64","FLOAT"),
    ("boolean","INTEGER"),
    ("enumeration","TEXT"),
    ("binary","TEXT")])

type_class.update((t,"TEXT") for t in
                  ("string", "identityref", "instance-identifier","bits",'leafref','empty','anyxml'))

def pyang_plugin_init():
    plugin.register_plugin(SqlPlugin())

class SqlPlugin(plugin.PyangPlugin):

    outputDoc = "\n--SQL DDL auto-generated by pyang with '-f sql'";

    def add_output_format(self, fmts):
        self.multiple_modules = True
        fmts['sql'] = self

    def setup_fmt(self, ctx):
        ctx.implicit_errors = False

    def emit(self, ctx, modules, fd):
        """Main control function.

        Set up the top-level parts of the schema, then process
        recursively all nodes in all data trees, and finally emit the
        serialized schema.
        """

        self.verbose=ctx.opts.verbose
        for (epos, etag, eargs) in ctx.errors:
            if error.is_error(error.err_level(etag)):
                raise error.EmitError("Sql plugin needs a valid module")
        self.real_prefix = unique_prefixes(ctx)

        for module in self.real_prefix.keys():
            self.process_module(module)

        fd.write("--%s: %s%s\n" % (module.keyword, module.arg, self.outputDoc))

    def process_module(self, yam):
        if self.real_prefix[yam] in schemata:
            print("Module "+yam.arg+" already processed. Continuing.")
            return
        ns_uri = yam.search_one("namespace").arg
        if self.verbose:
            print("Handling module "+yam.arg+" as "+self.real_prefix[yam]+":"+ns_uri)

        for ch in yam.i_children[:]:
            if ch.keyword == "rpc":
                None
                #   self.process_rpc(ch,yam) TODO Add function
            elif ch.keyword == "notification":
                None
                # self.process_notifications(ch,yam) TODO Add function
            else:
                continue
            yam.i_children.remove(ch)
        self.process_tables(yam, self.real_prefix[yam], toplevel=True)

    def process_tables(self, node, prefix, childtables=[], childlisttables=[], ancestors=[], toplevel=False):
        """Process all children of `node`."""
        chs = node.i_children
        for ch in chs:
            if ch.keyword in ['leaf']:
                continue
            cfg = ch.search_one("config")
            if cfg is not None and cfg.arg == "false":
                continue
            sqlcreatetable = "\nCREATE TABLE "
            if self.verbose:
                print("Processing C: ", end="")
                print(ch.arg+"("+ch.keyword+")")

            if not toplevel:  # Leave out the module name from ancestors
                ancestors.append(node.arg.replace("-", "_"))
            if ch.keyword in ['container']:
                childtables.append(ch)
                children = []
                childrenlist = []
                self.process_tables(ch, prefix, children, childrenlist, ancestors)
                ancestors.append(ch.arg.replace("-", "_"))  # Temporarily add it in
                cols = self.process_columns(ch, childtables=children, ancestors=ancestors)
                ancestors.pop()
                sqlcreatetable = "\n--container" + sqlcreatetable + self.underscore(ch.arg, ancestors) + cols + ";"
                if len(children) > 0:
                    sqldeletetrigger = "\nCREATE TRIGGER " + self.underscore(ch.arg, ancestors) + \
                                       "_dt AFTER DELETE ON " + self.underscore(ch.arg, ancestors) + "\nBEGIN"
                    ancestors.append(ch.arg.replace("-", "_"))  # Temporarily add it in
                    for table in children:
                        triggerdelete = "\n    DELETE FROM " + self.underscore(table.arg, ancestors) +\
                                        " WHERE revision = OLD.revision;"
                        sqldeletetrigger += triggerdelete
                    for table in childrenlist:
                        triggerdelete = "\n    DELETE FROM " + self.underscore(table, ancestors) +\
                                        " WHERE revision = OLD.revision;"
                        sqldeletetrigger += triggerdelete
                    ancestors.pop()
                    sqldeletetrigger += "\nEND;"
                    sqlcreatetable += sqldeletetrigger

            elif ch.keyword in ['list']:
                childlisttables.append(ch.arg)
                keys = ch.search("key")
                cols = self.process_columns(ch, keys=keys, ancestors=ancestors, parentkeys=self.getparentkeys(node))
                sqlcreatetable = "\n--list" + sqlcreatetable + self.underscore(ch.arg, ancestors) + cols + ";\n"
                self.process_tables(ch, prefix, ancestors=ancestors)

            elif ch.keyword in ['leaf-list']:
                childlisttables.append(ch.arg)
                keys = [ch]
                cols = self.process_columns(ch, keys=keys, ancestors=ancestors, parentkeys=self.getparentkeys(node))
                sqlcreatetable = "\n--leaf-list" + sqlcreatetable + self.underscore(ch.arg, ancestors) + cols + ";\n"

            elif ch.keyword in ['choice']:
                sqlcreatetable = ""
                for case in ch.i_children:
                    for caseelem in case.i_children:
                        print("Processing choice:case:elem", ch.arg, case.arg, caseelem.arg)
                        if caseelem.keyword in ['container', 'list', 'leaf-list']:
                            self.process_tables(case, prefix, ancestors=ancestors)

            self.outputDoc += "\n" + sqlcreatetable
            if self.verbose:
                print(sqlcreatetable)
            if len(ancestors) > 0:
                ancestors.pop()

    def process_columns(self, node, keys=[], childtables=[], ancestors=[], parentkeys=[]):
        chs = []
        columns = []
        if node.keyword in ['leaf-list']:
            chs = [node]
        else:
            chs = node.i_children
        if len(keys) == 0:
            rev = "revision INTEGER NOT NULL PRIMARY KEY";
            columns.append(rev)

        for ch in chs:
            if ch.keyword in ['container', 'list'] or \
                    (ch.keyword in ['leaf-list'] and node.keyword not in ['leaf-list']):
                continue
            cfg = ch.search_one("config")
            if cfg is not None and cfg.arg == "false":
                continue
            if self.verbose:
                print("Processing F: ", end="")
                print(ch.arg+"("+ch.keyword+")")
            if ch.keyword in ['leaf', 'leaf-list']:
                column = self.create_sql_column(ch)
                columns.append(column)
            elif ch.keyword in ['choice']:
                for case in ch.i_children:
                    for caseelem in case.i_children:
                        if caseelem.keyword in ['leaf']:
                            print("Processing choice:case:leaf", ch.arg, case.arg, caseelem.arg)
                            column = self.create_sql_column(caseelem)
                            columns.append(self.underscore(column))

            else:
                print("Unexpected type", ch.keyword, "when processing", ch.arg)
        for ct in childtables:
            definefk = self.underscore(ct.arg) + "_fk INTEGER"
            if not ct.search_one("presence"):
                definefk += " NOT NULL"
            columns.append(definefk)

        for ct in childtables:  # All of the Foreign key constraints must come after the columns
            columns.append("FOREIGN KEY (" + self.underscore(ct.arg) + "_fk) REFERENCES " +
                           self.underscore(ct.arg, ancestors) + "(revision)")

        pk_constraint = "CONSTRAINT " + self.underscore(node.arg) + "_pk PRIMARY KEY ("

        for pkey in parentkeys:
            fk_constraint1 = self.underscore(pkey['name']) + "_fk " + pkey['type'] + " NOT NULL"
            columns.append(fk_constraint1)
            pk_constraint += self.underscore(pkey['name']) + "_fk, "
        for pkey in parentkeys:
            fk_constraint2 = "FOREIGN KEY(" + self.underscore(pkey['name']) + "_fk) REFERENCES " + \
                             self.underscore(None, ancestors) + "(" + self.underscore(pkey['name']) + ")"
            columns.append(fk_constraint2)

        if len(keys) > 0:  # In the case of lists need to add a compound primary key
            for key in keys:
                pk_constraint += self.underscore(key.arg)
            pk_constraint += ")"
            columns.append(pk_constraint)

        return " (\n    " + ",\n    ".join(columns) + "\n)"

    def create_sql_column(self, node):
        default = node.search_one("default")

        types=self.get_types(node)
        unionElem=None
        columndef = self.underscore(node.arg)
        if len(types)>1:
            columndef += " TEXT"
            # unionElem = ET.SubElement(stEleme, XSNSB+"union")
        for ftyp in types:
            # if unionElem is not None:
                # stEleme=ET.SubElement(unionElem, XSNSB+"simpleType")
            columndef += (" " + type_class[ftyp.arg])

        if node.search_one("mandatory"):
            columndef += " NOT NULL"
        return columndef

    @staticmethod
    def get_types(node):
        res = []

        def resolve(typ):
            if typ.arg == "union":
                for ut in typ.i_type_spec.types: resolve(ut)
            elif typ.i_typedef is not None:
                resolve(typ.i_typedef.search_one("type"))
            else:
                res.append(typ)
        typ = node.search_one("type")
        if typ.arg == "leafref":
            resolve(node.i_leafref_ptr[0].search_one("type"))
        else:
            resolve(typ)
        return res

    @staticmethod
    def underscore(name, ancestors=[]):
        result=""
        if name is None:
            result = "_".join(ancestors)
        elif len(ancestors) == 0:
            result = name.replace("-", "_")
        else:
            result = "_".join(ancestors) + "_" + name.replace("-", "_")

        if result in ['group', 'create', 'insert', 'select']:  # Also remove SQLite keywords
            result = result + "1"
        return result

    @staticmethod
    def getparentkeys(parentnode):
        parentkeys = list()
        parentkeys.append({"name": "revision", "type": "INTEGER"})
        for k in parentnode.search("key"):
            parentkey = dict()
            parentkey["name"] = k.arg
            # kattr = parentnode.i_children[k.arg]
            # parentkey["type"] = type_class[SqlPlugin.get_types(kattr)]
            parentkey["type"] = "TEXT"
            parentkeys.append(parentkey)

        return parentkeys
