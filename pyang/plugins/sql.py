"""SQL plugin

Creates SQL schema from YANG files.
"""

from pyang import plugin, statements, error
from pyang.util import unique_prefixes

import optparse

"""Dictionary of SQL namespaces. Key will be the prefix of yang model"""
schemata={}

type_class = dict([
    ("int8", "INTEGER"),
    ("uint8", "INTEGER"),
    ("int16", "INTEGER"),
    ("uint16", "INTEGER"),
    ("int32", "INTEGER"),
    ("uint32", "INTEGER"),
    ("int64", "INTEGER"),
    ("uint64", "INTEGER"),
    ("decimal64", "FLOAT"),
    ("boolean", "INTEGER"),
    ("enumeration", "TEXT"),
    ("binary", "TEXT")])

type_class.update((t, "TEXT") for t in
                  ("string", "identityref", "instance-identifier", "bits", 'leafref', 'empty', 'anyxml'))


def pyang_plugin_init():
    plugin.register_plugin(SqlPlugin())


class SqlPlugin(plugin.PyangPlugin):

    outputDoc = ""
    attachList = list()

    ancestorcount = 100
    sampledata = False
    dbschema = False

    def add_opts(self, optparser):
        optlist = [
            optparse.make_option("--sql-ancestor-count",
                                 dest="ancestorcount",
                                 default=100,
                                 help="The number of ancestors to include in the name of a table (default 100 (all))."),
            optparse.make_option("--sql-sample-data",
                                 action="store_true",
                                 dest="sqlsample",
                                 default=False,
                                 help="Export sample data along with table definitions."),
            optparse.make_option("--db-schema",
                                 action="store_true",
                                 dest="dbschema",
                                 default=False,
                                 help="Prefix each table with an autogenerated db schema name"),
        ]
        g = optparser.add_option_group(
            "SQL generator output specific options")
        g.add_options(optlist)

    def add_output_format(self, fmts):
        self.multiple_modules = True
        fmts['sql'] = self

    def setup_fmt(self, ctx):
        ctx.implicit_errors = False

    def emit(self, ctx, modules, fd):
        """Main control function.

        Set up the top-level parts of the schema, then process
        recursively all nodes in all data trees, and finally emit the
        serialized schema.
        """

        self.verbose=ctx.opts.verbose
        for (epos, etag, eargs) in ctx.errors:
            if error.is_error(error.err_level(etag)):
                raise error.EmitError("Sql plugin needs a valid module")
        self.real_prefix = unique_prefixes(ctx)

        self.ancestorcount = int(ctx.opts.ancestorcount)
        self.sampledata = bool(ctx.opts.sqlsample)
        self.dbschema = bool(ctx.opts.dbschema)

        genstmt = "--SQL DDL auto-generated by pyang with '-f sql'"
        genstmt += "\n--Generated with --sql-ancestor-count=" + str(self.ancestorcount)
        genstmt += ", --sql-sample-data:" + str(self.sampledata) + " and --db-schema:" + str(self.dbschema)

        for module in self.real_prefix.keys():
            self.process_module(module)

        attachstmt = ""
        for a in self.attachList:
            for mod in self.real_prefix:
                if self.real_prefix[mod] == a:
                    attachstmt += ("\n--ATTACH DATABASE '" + mod.arg + "@" + mod.i_latest_revision +
                                   ".db' AS " + self.underscore(a) + ";")

        fd.write("%s%s%s\n" % (genstmt, attachstmt, self.outputDoc))


    def process_module(self, yam):
        if self.real_prefix[yam] in schemata:
            print("Module "+yam.arg+" already processed. Continuing.")
            return
        ns_uri = yam.search_one("namespace").arg
        if self.verbose:
            print("Handling module "+yam.arg+" as "+self.real_prefix[yam]+":"+ns_uri)

        for ch in yam.i_children[:]:
            if ch.keyword == "rpc":
                None
                #   self.process_rpc(ch,yam) TODO Add function
            elif ch.keyword == "notification":
                None
                # self.process_notifications(ch,yam) TODO Add function
            else:
                continue
            yam.i_children.remove(ch)
        self.process_tables(yam, self.real_prefix[yam], toplevel=True)

    def process_tables(self, node, prefix, childtables=[], childlisttables=[], ancestors=[], toplevel=False):
        """Process all children of `node`."""
        chs = node.i_children

        if toplevel and len(chs) > 0:
            self.outputDoc += ("\n.open " + node.arg + "@" + node.i_latest_revision + ".db")

        for ch in chs:
            if ch.keyword in ['leaf']:
                continue
            cfg = ch.search_one("config")
            if cfg is not None and cfg.arg == "false":
                continue
            sqlcreatetable = "\nCREATE TABLE "
            sqlinserttable = "\nINSERT INTO "
            if self.dbschema:  # Add in a schema name to the table name
                schema = self.underscore(prefix)
                sqlcreatetable += (schema + ".")
                sqlinserttable += (schema + ".")
            if prefix not in self.attachList:
                self.attachList.append(prefix)
            if self.verbose:
                print("Processing Tbl: ", end="")
                print(ch.arg+"("+ch.keyword+")")

            if not (toplevel or node.keyword in ['case']):  # Leave out the module name from ancestors
                ancestors.append(node.arg.replace("-", "_"))
            if ch.keyword in ['container']:
                childtables.append(ch)
                children = []
                childrenlist = []
                self.process_tables(ch, prefix, children, childrenlist, ancestors)
                cols, samplecols = self.process_columns(ch, childtables=children, ancestors=ancestors)
                sqlcreatetable = "\n--container" + sqlcreatetable + self.underscore(ch.arg, ancestors) + cols + ";"
                sqlinserttable = "\n" + sqlinserttable + self.underscore(ch.arg, ancestors) + samplecols + ";\n"
                if len(children) > 0:
                    sqldeletetrigger = "\nCREATE TRIGGER " + self.underscore(ch.arg, ancestors) + \
                                       "_dt AFTER DELETE ON " + self.underscore(ch.arg, ancestors) + "\nBEGIN"
                    ancestors.append(ch.arg.replace("-", "_"))  # Temporarily add it in
                    for table in children:
                        triggerdelete = "\n    DELETE FROM " + self.underscore(table.arg, ancestors) +\
                                        " WHERE revision = OLD.revision;"
                        sqldeletetrigger += triggerdelete
                    for table in childrenlist:
                        triggerdelete = "\n    DELETE FROM " + self.underscore(table, ancestors) +\
                                        " WHERE revision = OLD.revision;"
                        sqldeletetrigger += triggerdelete
                    ancestors.pop()
                    sqldeletetrigger += "\nEND;"
                    sqlcreatetable += sqldeletetrigger

            elif ch.keyword in ['list']:
                childlisttables.append(ch.arg)
                children = []
                keys = ch.search("key")
                self.process_tables(ch, prefix, children, ancestors=ancestors)
                cols, samplecols = self.process_columns(ch, childtables=children, keys=keys,
                                                        ancestors=ancestors, parentkeys=self.getparentkeys(node), idx=0)
                sqlcreatetable = "\n--list" + sqlcreatetable + self.underscore(ch.arg, ancestors) + cols + ";\n"
                if self.sampledata:
                    sqlinserttable = "\n" + sqlinserttable + self.underscore(ch.arg, ancestors) + samplecols + ";\n"

                    # For lists we'd like a few instances to be created
                    cols, samplecols = self.process_columns(ch, childtables=children, keys=keys, ancestors=ancestors,
                                                            parentkeys=self.getparentkeys(node), idx=1)
                    sqlinserttable += "\nINSERT INTO "
                    if self.dbschema:  # Add in a schema name to the table name
                        sqlinserttable += (self.underscore(prefix) + ".")
                    sqlinserttable += self.underscore(ch.arg, ancestors) + samplecols + ";\n"

                    # And another with idx=2
                    cols, samplecols = self.process_columns(ch, childtables=children, keys=keys, ancestors=ancestors,
                                                            parentkeys=self.getparentkeys(node), idx=2)
                    sqlinserttable += "\nINSERT INTO "
                    if self.dbschema:  # Add in a schema name to the table name
                        sqlinserttable += (self.underscore(prefix) + ".")
                    sqlinserttable += self.underscore(ch.arg, ancestors) + samplecols + ";\n"

            elif ch.keyword in ['leaf-list']:
                childlisttables.append(ch.arg)
                keys = [ch]
                cols, samplecols = self.process_columns(ch, keys=keys, ancestors=ancestors,
                                                        parentkeys=self.getparentkeys(node))
                sqlcreatetable = "\n--leaf-list" + sqlcreatetable + self.underscore(ch.arg, ancestors) + cols + ";\n"
                sqlinserttable = "\n" + sqlinserttable + self.underscore(ch.arg, ancestors) + samplecols + ";\n"

            elif ch.keyword in ['choice']:
                sqlcreatetable = ""
                sqlinserttable = ""
                for case in ch.i_children:
                    self.process_tables(case, prefix, childtables, childlisttables, ancestors=ancestors)

            self.outputDoc += "\n" + sqlcreatetable
            if self.verbose:
                print(sqlcreatetable)
            if self.sampledata:
                self.outputDoc += "\n" + sqlinserttable
                if self.verbose:
                    print(sqlinserttable)
            if not (toplevel or node.keyword in ['case']):
                ancestors.pop()

    def process_columns(self, node, keys=[], childtables=[], ancestors=[], parentkeys=[], idx=0):
        ancestors.append(node.arg.replace("-", "_"))  # Temporarily add it in
        chs = []
        columns = []
        samplenames = []
        samplevalues = []
        if node.keyword in ['leaf-list']:
            chs = [node]
        else:
            chs = node.i_children
        if len(keys) == 0:
            rev = "revision INTEGER NOT NULL PRIMARY KEY";
            columns.append(rev)
            samplenames.append("revision")
            samplevalues.append("0")

        for ch in chs:
            if ch.keyword in ['container', 'list', 'case'] or \
                    (ch.keyword in ['leaf-list'] and node.keyword not in ['leaf-list']):
                continue
            cfg = ch.search_one("config")
            if cfg is not None and cfg.arg == "false":
                continue
            if self.verbose:
                print("Processing Col: ", end="")
                print(ch.arg+"("+ch.keyword+")")
            if ch.keyword in ['leaf', 'leaf-list']:
                column = self.create_sql_column(ch)
                columns.append(column)
                samplenames.append(column.split(" ")[0])
                default = ch.search_one("default")
                if default is not None:
                    if default.arg.isdigit():
                        samplevalues.append(default.arg)
                    elif default.arg in ['true']:
                        samplevalues.append("1")
                    elif default.arg in ['false']:
                        samplevalues.append("0")
                    else:
                        samplevalues.append("'" + default.arg + "'")

                else:
                    samplevalues.append(str(idx))

            elif ch.keyword in ['choice']:  # For leaf(s) directly under a case statement
                for case in ch.i_children:
                    for caseelem in case.i_children:
                        if caseelem.keyword in ['leaf']:
                            print("Processing choice:case:leaf", ch.arg, case.arg, caseelem.arg)
                            column = self.create_sql_column(caseelem)
                            columns.append(self.underscore(column))
                            samplenames.append(column.split(" ")[0])
                            samplevalues.append(str(idx))

            else:
                print("Unexpected type", ch.keyword, "when processing", ch.arg)
        for ct in childtables:
            definefk = self.underscore(ct.arg) + "_fk INTEGER"
            parent = ct.parent
            if parent and parent.keyword in ['case']:
                print(ct.arg, "has a case as a parent")
            if not (ct.search_one("presence") or (ct.parent is not None and ct.parent.keyword in ['case'])):
                definefk += " NOT NULL"
            columns.append(definefk)
            samplenames.append(definefk.split(" ")[0])
            samplevalues.append("0")

        pk_constraint = "CONSTRAINT " + self.underscore(node.arg) + "_pk PRIMARY KEY ("

        for pkey in parentkeys:
            fk_constraint1 = self.underscore(pkey['name']) + "_fk " + pkey['type'] + " NOT NULL"
            columns.append(fk_constraint1)
            samplenames.append(fk_constraint1.split(" ")[0])
            samplevalues.append("0")
            pk_constraint += self.underscore(pkey['name']) + "_fk, "

        for ct in childtables:  # All of the Foreign key constraints must come after the columns
            fk_constraint1 = "FOREIGN KEY(" + self.underscore(ct.arg) + "_fk) REFERENCES "
            if self.dbschema:
                fk_constraint1 += (self.underscore(ct.top.i_prefix) + ".")
            fk_constraint1 += self.underscore(ct.arg, ancestors) + "(revision)"
            columns.append(fk_constraint1)
        ancestors.pop()  # Important to pop it here as we do not want the last piece in the parent keys

        for pkey in parentkeys:
            fk_constraint2 = "FOREIGN KEY(" + self.underscore(pkey['name']) + "_fk) REFERENCES "
            if self.dbschema:
                fk_constraint2 += (self.underscore(node.top.i_prefix) + ".")
            fk_constraint2 += self.underscore(None, ancestors) + "(" + self.underscore(pkey['name']) + ")"
            columns.append(fk_constraint2)

        if len(keys) > 0:  # In the case of lists need to add a compound primary key
            for key in keys:
                pk_constraint += self.underscore(key.arg)
            pk_constraint += ")"
            columns.append(pk_constraint)

        return " (\n    " + ",\n    ".join(columns) + "\n)", \
               " (\n    " + ",\n    ".join(samplenames) + "\n) VALUES (\n    " + ",\n    ".join(samplevalues) + "\n)"

    def create_sql_column(self, node):
        types=self.get_types(node)
        unionElem=None
        columndef = self.underscore(node.arg)
        if len(types)>1:
            columndef += " TEXT"
            # unionElem = ET.SubElement(stEleme, XSNSB+"union")
        for ftyp in types:
            # if unionElem is not None:
                # stEleme=ET.SubElement(unionElem, XSNSB+"simpleType")
            columndef += (" " + type_class[ftyp.arg])

        if node.search_one("mandatory"):
            columndef += " NOT NULL"
        return columndef

    @staticmethod
    def get_types(node):
        res = []

        def resolve(typ):
            if typ.arg == "union":
                for ut in typ.i_type_spec.types: resolve(ut)
            elif typ.i_typedef is not None:
                resolve(typ.i_typedef.search_one("type"))
            else:
                res.append(typ)
        typ = node.search_one("type")
        if typ.arg == "leafref":
            resolve(node.i_leafref_ptr[0].search_one("type"))
        else:
            resolve(typ)
        return res

    def underscore(self, name, ancestors=[]):
        result=""
        if len(ancestors) == 0 and name is None:
            return name
        elif len(ancestors) == 0:
            result = name.replace("-", "_")
        elif name is None:
            result = "_".join(ancestors[-(self.ancestorcount+1):])
        else:
            result = "_".join(ancestors[-self.ancestorcount:]) + "_" + name.replace("-", "_")

        if result in ['group', 'create', 'insert', 'select', 'if', 'index']:  # Also remove SQLite keywords
            result = result + "1"
        return result

    @staticmethod
    def getparentkeys(parentnode):
        parentkeys = list()
        if parentnode.keyword in ['module']:
            return parentkeys
        parentkeys.append({"name": "revision", "type": "INTEGER"})
        for k in parentnode.search("key"):
            parentkey = dict()
            parentkey["name"] = k.arg
            # kattr = parentnode.i_children[k.arg]
            # parentkey["type"] = type_class[SqlPlugin.get_types(kattr)]
            parentkey["type"] = "TEXT"
            parentkeys.append(parentkey)

        return parentkeys
