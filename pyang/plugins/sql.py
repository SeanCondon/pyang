"""SQL plugin

Creates SQL schema from YANG files.
"""

from pyang import plugin, statements, error
from pyang.util import unique_prefixes

"""Dictionary of SQL namespaces. Key will be the prefix of yang model"""
schemata={}

type_class = dict([
    ("int8", "INTEGER"),
    ("uint8", "INTEGER"),
    ("int16", "INTEGER"),
    ("uint16", "INTEGER"),
    ("int32", "INTEGER"),
    ("uint32","INTEGER"),
    ("int64", "INTEGER"),
    ("uint64","INTEGER"),
    ("decimal64","FLOAT"),
    ("boolean","INTEGER"),
    ("enumeration","INTEGER"),
    ("binary","TEXT")])

type_class.update((t,"TEXT") for t in
                  ("string", "identityref", "instance-identifier","bits",'leafref','empty','anyxml'))

def pyang_plugin_init():
    plugin.register_plugin(SqlPlugin())

class SqlPlugin(plugin.PyangPlugin):

    outputDoc = "\n--SQL DDL auto-generated by pyang with '-f sql'";

    def add_output_format(self, fmts):
        self.multiple_modules = True
        fmts['sql'] = self

    def setup_fmt(self, ctx):
        ctx.implicit_errors = False

    def emit(self, ctx, modules, fd):
        """Main control function.

        Set up the top-level parts of the schema, then process
        recursively all nodes in all data trees, and finally emit the
        serialized schema.
        """

        self.verbose=ctx.opts.verbose
        for (epos, etag, eargs) in ctx.errors:
            if error.is_error(error.err_level(etag)):
                raise error.EmitError("Sql plugin needs a valid module")
        self.real_prefix = unique_prefixes(ctx)

        for module in self.real_prefix.keys():
            self.process_module(module)

        fd.write("--%s: %s%s\n" % (module.keyword, module.arg, self.outputDoc))

    def process_module(self, yam):
        if self.real_prefix[yam] in schemata:
            print("Module "+yam.arg+" already processed. Continuing.")
            return
        ns_uri = yam.search_one("namespace").arg
        if self.verbose:
            print("Handling module "+yam.arg+" as "+self.real_prefix[yam]+":"+ns_uri)

        for ch in yam.i_children[:]:
            if ch.keyword == "rpc":
                None
                #   self.process_rpc(ch,yam) TODO Add function
            elif ch.keyword == "notification":
                None
                # self.process_notifications(ch,yam) TODO Add function
            else:
                continue
            yam.i_children.remove(ch)
        self.process_tables(yam, self.real_prefix[yam])

    def process_tables(self, node, prefix, childtables=[], childlisttables=[]):
        """Process all children of `node`."""
        chs = node.i_children
        for ch in chs:
            if ch.keyword in ['leaf', 'leaf-list']:
                continue
            cfg = ch.search_one("config")
            if cfg is not None and cfg.arg == "false":
                continue
            sqlcreatetable = "\nCREATE TABLE "
            if self.verbose:
                print("Processing C: ", end="")
                print(ch.arg+"("+ch.keyword+")")

            if ch.keyword in ['container']:
                childtables.append(ch.arg)
                children = []
                childrenlist = []
                self.process_tables(ch, prefix, children, childrenlist)
                cols = self.process_columns(ch, childtables=children)
                sqlcreatetable = sqlcreatetable + self.underscore(ch.arg) + cols + ";"
                if len(children) > 0:
                    sqldeletetrigger = "\nCREATE TRIGGER " + self.underscore(ch.arg) + \
                                       "_dt AFTER DELETE ON " + self.underscore(ch.arg) + "\nBEGIN"
                    for table in children:
                        triggerdelete = "\n    DELETE FROM " + self.underscore(table) + " WHERE revision = OLD.revision;"
                        sqldeletetrigger += triggerdelete
                    for table in childrenlist:
                        triggerdelete = "\n    DELETE FROM " + self.underscore(table) + " WHERE revision = OLD.revision;"
                        sqldeletetrigger += triggerdelete
                    sqldeletetrigger += "\nEND;"
                    sqlcreatetable += sqldeletetrigger

            elif ch.keyword in ['list']:
                childlisttables.append(ch.arg)
                keys = ch.search("key")
                cols = self.process_columns(ch, keys=keys)
                sqlcreatetable = sqlcreatetable + self.underscore(ch.arg) + cols + ";\n"
                self.process_tables(ch, prefix)

            self.outputDoc += "\n" + sqlcreatetable
            if self.verbose:
                print(sqlcreatetable)

    def process_columns(self, node, keys=[], childtables=[]):
        chs = node.i_children
        columns = []
        rev = "\n    revision INTEGER NOT NULL";
        if len(keys) == 0:
            rev = rev + " PRIMARY KEY"
        columns.append(rev)
        for ch in chs:
            if ch.keyword in ['container', 'list']:
                continue
            cfg = ch.search_one("config")
            if cfg is not None and cfg.arg == "false":
                continue
            if self.verbose:
                print("Processing F: ", end="")
                print(ch.arg+"("+ch.keyword+")")
            if ch.keyword in ['leaf']:
                column = self.create_sql_column(ch)
                columns.append(self.underscore(column))
            elif ch.keyword in ['leaf-list']:
                # TODO: not yet supported
                None
        for ct in childtables:
            columns.append(self.underscore(ct) + "_fk INTEGER NOT NULL")

        for ct in childtables:  # All of the Foreign key constraints must come after the columns
            columns.append("FOREIGN KEY (" + self.underscore(ct) + "_fk) REFERENCES " +
                           self.underscore(ct) + "(revision)")

        if len(keys) > 0:  # In the case of lists need to add a compound primary key
            pk_constraint = "CONSTRAINT " + node.arg + "_pk PRIMARY KEY (revision, "
            for key in keys:
                pk_constraint += key.arg
            pk_constraint += ")"
            columns.append(self.underscore(pk_constraint))

        return " (" + ",\n    ".join(columns) + "\n)"

    def create_sql_column(self, node):
        default = node.search_one("default")

        types=self.get_types(node)
        unionElem=None
        if len(types)>1:
            return type_class["union - not supported"]
            # unionElem = ET.SubElement(stEleme, XSNSB+"union")
        for ftyp in types:
            # if unionElem is not None:
                # stEleme=ET.SubElement(unionElem, XSNSB+"simpleType")
            return node.arg + " " + type_class[ftyp.arg]

    def get_types(self, node):
        res = []
        def resolve(typ):
            if typ.arg == "union":
                for ut in typ.i_type_spec.types: resolve(ut)
            elif typ.i_typedef is not None:
                resolve(typ.i_typedef.search_one("type"))
            else:
                res.append(typ)
        typ = node.search_one("type")
        if typ.arg == "leafref":
            resolve(node.i_leafref_ptr[0].search_one("type"))
        else:
            resolve(typ)
        return res

    def underscore(self, name):
        return name.replace("-", "_")